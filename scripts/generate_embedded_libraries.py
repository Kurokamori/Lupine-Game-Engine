#!/usr/bin/env python3
"""
Lupine Engine - Embedded Library Generator

This script generates C++ header files containing embedded static library data
for cross-platform export. It takes static libraries from the thirdparty directory
and embeds them as byte arrays in the executable.

Supports both Linux and Windows library embedding for full cross-platform export.
"""

import os
import sys
import argparse
from pathlib import Path
import hashlib

def generate_header_guard(filename):
    """Generate a header guard from filename"""
    guard = filename.upper().replace('.', '_').replace('/', '_').replace('\\', '_')
    return f"LUPINE_EMBEDDED_{guard}_H"

def generate_variable_name(lib_name, platform=None):
    """Generate a valid C++ variable name from library name"""
    # Replace invalid characters with underscores
    var_name = lib_name.replace('-', '_').replace('.', '_').replace('/', '_')
    if platform:
        return f"embedded_{platform}_{var_name}_data"
    else:
        return f"embedded_{var_name}_data"

def read_library_file(file_path):
    """Read a library file and return its data as bytes"""
    try:
        with open(file_path, 'rb') as f:
            return f.read()
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        return None

def calculate_checksum(data):
    """Calculate SHA-256 checksum of data"""
    return hashlib.sha256(data).hexdigest()

def generate_byte_array(data, var_name):
    """Generate C++ byte array declaration"""
    lines = [f"const uint8_t {var_name}[] = {{"]
    
    # Write data in chunks of 16 bytes per line
    for i in range(0, len(data), 16):
        chunk = data[i:i+16]
        hex_values = [f"0x{byte:02x}" for byte in chunk]
        lines.append(f"    {', '.join(hex_values)},")
    
    lines.append("};")
    lines.append(f"const size_t {var_name}_size = {len(data)};")
    lines.append("")
    
    return '\n'.join(lines)

def find_libraries_by_platform(thirdparty_dir, platform):
    """Find all static libraries for a specific platform in the thirdparty directory"""
    if platform == "linux":
        lib_dir = Path(thirdparty_dir) / "linux_x64-static"
        lib_extension = ".a"
    elif platform == "windows":
        lib_dir = Path(thirdparty_dir) / "windows_x64-static"
        lib_extension = ".lib"
    else:
        print(f"Unsupported platform: {platform}")
        return []

    if not lib_dir.exists():
        print(f"{platform.title()} library directory not found: {lib_dir}")
        return []

    libraries = []

    # Common library patterns
    lib_patterns = [
        f"*/lib/*{lib_extension}",
        f"*/lib/*/*{lib_extension}",
        f"lib/*{lib_extension}"
    ]

    for pattern in lib_patterns:
        for lib_file in lib_dir.glob(pattern):
            if lib_file.is_file():
                # Get relative path from platform directory
                rel_path = lib_file.relative_to(lib_dir)
                lib_name = lib_file.stem

                # Remove 'lib' prefix if present (common on Linux)
                if lib_name.startswith('lib') and platform == "linux":
                    lib_name = lib_name[3:]

                libraries.append({
                    'name': lib_name,
                    'path': lib_file,
                    'relative_path': rel_path
                })

def find_linux_libraries(thirdparty_dir):
    """Find all Linux static libraries in the thirdparty directory"""
    return find_libraries_by_platform(thirdparty_dir, "linux")

def find_windows_libraries(thirdparty_dir):
    """Find all Windows static libraries in the thirdparty directory"""
    return find_libraries_by_platform(thirdparty_dir, "windows")
    
    return libraries

def generate_libraries_header(libraries, output_file, platform):
    """Generate the embedded libraries header file for a specific platform"""

    header_filename = f"embedded_{platform}_libraries.h"
    header_guard = generate_header_guard(header_filename)
    platform_title = platform.title()

    content = [
        f"#ifndef {header_guard}",
        f"#define {header_guard}",
        "",
        "// Auto-generated file - DO NOT EDIT",
        f"// Generated by scripts/generate_embedded_libraries.py --platform {platform}",
        "",
        "#include <cstdint>",
        "#include <unordered_map>",
        "#include <vector>",
        "#include <string>",
        "",
        "namespace Lupine {",
        ""
    ]

    # Generate byte arrays for each library
    library_vars = []

    for lib in libraries:
        print(f"Processing library: {lib['name']} ({lib['path']})")

        data = read_library_file(lib['path'])
        if data is None:
            continue

        var_name = generate_variable_name(lib['name'], platform)
        library_vars.append((lib['name'], var_name, len(data)))

        content.append(f"// Library: {lib['name']} ({lib['relative_path']})")
        content.append(f"// Size: {len(data)} bytes")
        content.append(f"// Checksum: {calculate_checksum(data)}")
        content.append(generate_byte_array(data, var_name))

    # Generate the map function
    content.extend([
        "/**",
        f" * @brief Get map of embedded {platform_title} libraries",
        " * @return Map of library name to data",
        " */",
        f"inline std::unordered_map<std::string, std::vector<uint8_t>> GetEmbedded{platform_title}Libraries() {{",
        "    std::unordered_map<std::string, std::vector<uint8_t>> libraries;",
        ""
    ])

    for lib_name, var_name, size in library_vars:
        content.extend([
            f"    libraries[\"{lib_name}\"] = std::vector<uint8_t>(",
            f"        {var_name}, {var_name} + {var_name}_size);",
            ""
        ])

    content.extend([
        "    return libraries;",
        "}",
        "",
        "} // namespace Lupine",
        "",
        f"#endif // {header_guard}",
        ""
    ])

    # Write to file
    try:
        with open(output_file, 'w') as f:
            f.write('\n'.join(content))
        print(f"Generated {output_file}")
        return True
    except Exception as e:
        print(f"Error writing {output_file}: {e}")
        return False

def generate_linux_libraries_header(libraries, output_file):
    """Generate the embedded Linux libraries header file"""
    return generate_libraries_header(libraries, output_file, "linux")

def generate_windows_libraries_header(libraries, output_file):
    """Generate the embedded Windows libraries header file"""
    return generate_libraries_header(libraries, output_file, "windows")
    
    # Write to file
    try:
        with open(output_file, 'w') as f:
            f.write('\n'.join(content))
        print(f"Generated embedded libraries header: {output_file}")
        print(f"Embedded {len(library_vars)} libraries")
        
        total_size = sum(size for _, _, size in library_vars)
        print(f"Total embedded size: {total_size:,} bytes ({total_size / 1024 / 1024:.2f} MB)")
        
    except Exception as e:
        print(f"Error writing output file {output_file}: {e}")
        return False
    
    return True

def main():
    parser = argparse.ArgumentParser(description="Generate embedded library headers for Lupine Engine")
    parser.add_argument("--platform", choices=["linux", "windows", "both"], default="both",
                       help="Platform to generate libraries for (default: both)")
    parser.add_argument("--thirdparty-dir", default="thirdparty",
                       help="Path to thirdparty directory (default: thirdparty)")
    parser.add_argument("--output-dir", default="src/export",
                       help="Output directory for generated headers (default: src/export)")
    parser.add_argument("--force", action="store_true",
                       help="Force regeneration even if output files exist")

    args = parser.parse_args()

    # Resolve paths
    thirdparty_dir = Path(args.thirdparty_dir).resolve()
    output_dir = Path(args.output_dir).resolve()

    if not thirdparty_dir.exists():
        print(f"Error: Thirdparty directory not found: {thirdparty_dir}")
        return 1

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    platforms_to_process = []
    if args.platform == "both":
        platforms_to_process = ["linux", "windows"]
    else:
        platforms_to_process = [args.platform]

    success_count = 0

    for platform in platforms_to_process:
        print(f"\n=== Processing {platform.title()} Libraries ===")

        # Output file
        output_file = output_dir / f"embedded_{platform}_libraries.h"

        # Check if we should regenerate
        if output_file.exists() and not args.force:
            print(f"Output file already exists: {output_file}")
            print("Use --force to regenerate")
            continue

        print(f"Scanning for {platform} libraries in: {thirdparty_dir}")

        # Find libraries for this platform
        if platform == "linux":
            libraries = find_linux_libraries(thirdparty_dir)
        elif platform == "windows":
            libraries = find_windows_libraries(thirdparty_dir)

        if not libraries:
            print(f"No {platform} libraries found!")
            if platform == "linux":
                print("Make sure you have run scripts/download_linux_libraries.sh first")
            else:
                print(f"Make sure you have {platform}_x64-static directory with .lib files")
            continue

        print(f"Found {len(libraries)} {platform} libraries:")
        for lib in libraries:
            print(f"  - {lib['name']} ({lib['relative_path']})")

        # Generate header
        if platform == "linux":
            success = generate_linux_libraries_header(libraries, output_file)
        elif platform == "windows":
            success = generate_windows_libraries_header(libraries, output_file)

        if success:
            print(f"\nâœ“ {platform.title()} library generation completed successfully!")
            print(f"Include the generated header in your build with:")
            print(f"  #include \"{output_file.name}\"")
            print(f"And define LUPINE_EMBED_{platform.upper()}_LIBRARIES in your build system")
            success_count += 1
        else:
            print(f"\nâœ— {platform.title()} library generation failed!")

    if success_count == 0:
        print("\nNo libraries were successfully generated!")
        return 1
    elif success_count == len(platforms_to_process):
        print(f"\nðŸŽ‰ All {success_count} platform(s) generated successfully!")
        return 0
    else:
        print(f"\nâš  Partial success: {success_count}/{len(platforms_to_process)} platform(s) generated")
        return 1

if __name__ == "__main__":
    sys.exit(main())
